"use strict";(()=>{var e={};e.id=220,e.ids=[220],e.modules={5129:e=>{e.exports=require("gologin")},2934:e=>{e.exports=require("next/dist/client/components/action-async-storage.external.js")},4580:e=>{e.exports=require("next/dist/client/components/request-async-storage.external.js")},5869:e=>{e.exports=require("next/dist/client/components/static-generation-async-storage.external.js")},399:e=>{e.exports=require("next/dist/compiled/next-server/app-page.runtime.prod.js")},517:e=>{e.exports=require("next/dist/compiled/next-server/app-route.runtime.prod.js")},2615:e=>{e.exports=require("http")},8791:e=>{e.exports=require("https")},8621:e=>{e.exports=require("punycode")},6162:e=>{e.exports=require("stream")},7360:e=>{e.exports=require("url")},1568:e=>{e.exports=require("zlib")},7250:e=>{e.exports=import("puppeteer-core")},3052:(e,o,t)=>{t.a(e,async(e,s)=>{try{t.r(o),t.d(o,{originalPathname:()=>v,patchFetch:()=>c,requestAsyncStorage:()=>g,routeModule:()=>u,serverHooks:()=>p,staticGenerationAsyncStorage:()=>d});var r=t(9303),a=t(8716),i=t(670),n=t(1212),l=e([n]);n=(l.then?(await l)():l)[0];let u=new r.AppRouteRouteModule({definition:{kind:a.x.APP_ROUTE,page:"/api/queue/process/route",pathname:"/api/queue/process",filename:"route",bundlePath:"app/api/queue/process/route"},resolvedPagePath:"C:\\Users\\HP\\Documents\\GitHub\\GologinAutomation\\gologin\\app\\api\\queue\\process\\route.ts",nextConfigOutput:"standalone",userland:n}),{requestAsyncStorage:g,staticGenerationAsyncStorage:d,serverHooks:p}=u,v="/api/queue/process/route";function c(){return(0,i.patchFetch)({serverHooks:p,staticGenerationAsyncStorage:d})}s()}catch(e){s(e)}})},1212:(e,o,t)=>{t.a(e,async(e,s)=>{try{t.r(o),t.d(o,{POST:()=>l});var r=t(9692),a=t(3870),i=t(7070),n=e([a]);async function l(e){try{let e=await (0,r.t)(),{data:o,error:t}=await e.from("settings").select("value").eq("key","gologin_api_key").single();if(t||!o?.value)return i.NextResponse.json({error:"GoLogin API key not found. Please save it in Settings first."},{status:400});let s=new a.w(o.value);return await s.processPendingTasks(),i.NextResponse.json({success:!0,message:"Queue processed"})}catch(e){return console.error("[v0] Error processing queue:",e),i.NextResponse.json({error:e.message},{status:500})}}a=(n.then?(await n)():n)[0],s()}catch(e){s(e)}})},3870:(e,o,t)=>{t.a(e,async(e,s)=>{try{t.d(o,{w:()=>n});var r=t(9692),a=t(1978),i=e([a]);a=(i.then?(await i)():i)[0];class n{constructor(e){this.isProcessing=!1,this.gologinApiKey=e}async processPendingTasks(){if(this.isProcessing){console.log("[v0] Queue already processing, skipping");return}this.isProcessing=!0,console.log("[v0] ========================================"),console.log("[v0] Starting task queue processing"),console.log("[v0] ========================================");try{let e=await (0,r.t)();console.log("[v0] Fetching pending tasks...");let{data:o,error:t}=await e.from("automation_tasks").select("*").eq("status","pending").lte("scheduled_at",new Date().toISOString()).order("priority",{ascending:!1}).order("scheduled_at",{ascending:!0}).limit(10);if(t)throw console.error("[v0] ❌ Error fetching tasks:",t),t;if(!o||0===o.length){console.log("[v0] No pending tasks to process");return}console.log(`[v0] ✓ Found ${o.length} pending tasks`),o.forEach((e,o)=>{console.log(`[v0]   ${o+1}. ${e.task_type} (ID: ${e.id})`)}),console.log("[v0] Fetching behavior pattern...");let{data:s,error:a}=await e.from("behavior_patterns").select("*").eq("is_default",!0).single();if(a)throw console.error("[v0] ❌ Error fetching behavior pattern:",a),a;console.log("[v0] ✓ Behavior pattern loaded"),console.log("[v0] Fetching GoLogin mode setting...");let{data:i}=await e.from("settings").select("value").eq("key","gologin_mode").single(),n=i?.value||"cloud";for(let e of(console.log(`[v0] ✓ GoLogin mode: ${n}`),o))await this.processTask(e,s,n);console.log("[v0] ========================================"),console.log("[v0] ✓ Task queue processing completed"),console.log("[v0] ========================================")}catch(e){console.error("[v0] ========================================"),console.error("[v0] ❌ Error processing task queue"),console.error("[v0] Error:",e.message),console.error("[v0] ========================================")}finally{this.isProcessing=!1}}async processTask(e,o,t){console.log("[v0] ========================================"),console.log(`[v0] Processing task ${e.id}`),console.log(`[v0] Task type: ${e.task_type}`),console.log("[v0] ========================================");try{let s=await (0,r.t)();console.log(`[v0] Fetching profile ${e.profile_id}...`);let{data:i,error:n}=await s.from("gologin_profiles").select("*").eq("id",e.profile_id).single();if(n)throw console.error("[v0] ❌ Error fetching profile:",n),n;if(console.log(`[v0] ✓ Profile loaded: ${i.profile_name}`),"running"===i.status){console.log(`[v0] ⚠️ Profile ${i.profile_name} is already running, skipping task`);return}console.log("[v0] Updating task status to 'running'..."),await s.from("automation_tasks").update({status:"running",started_at:new Date().toISOString()}).eq("id",e.id),console.log("[v0] ✓ Task status updated"),console.log("[v0] Updating profile status to 'running'..."),await s.from("gologin_profiles").update({status:"running"}).eq("id",i.id),console.log("[v0] ✓ Profile status updated"),console.log("[v0] Executing task...");let l=new a.Z(this.gologinApiKey,t,o.config),c=await l.executeTask(e,i);if(console.log("[v0] Task execution result:",{success:c.success,duration:c.duration,error:c.error||"none"}),console.log("[v0] [DEBUG] Checking if task is check_gmail_status..."),console.log("[v0] [DEBUG] Task type:",e.task_type),console.log("[v0] [DEBUG] Result object:",JSON.stringify(c,null,2)),"check_gmail_status"===e.task_type&&c.result){console.log("[v0] [DEBUG] Gmail status check detected, preparing profile update..."),console.log("[v0] [DEBUG] Result.result:",JSON.stringify(c.result,null,2));let e=c.result.status,o=c.result.message;console.log("[v0] [DEBUG] Updating profile with Gmail status:",{gmail_status:e,gmail_status_checked_at:new Date().toISOString(),gmail_status_message:o});let{data:t,error:r}=await s.from("gologin_profiles").update({gmail_status:e,gmail_status_checked_at:new Date().toISOString(),gmail_status_message:o}).eq("id",i.id).select();r?console.error("[v0] [DEBUG] ❌ Error updating Gmail status:",r):console.log("[v0] [DEBUG] ✓ Gmail status updated successfully:",t)}else console.log("[v0] [DEBUG] Not a Gmail status check task or no result data");console.log("[v0] Updating task final status..."),await s.from("automation_tasks").update({status:c.success?"completed":"failed",completed_at:new Date().toISOString(),error_message:c.error||null}).eq("id",e.id),console.log(`[v0] ✓ Task marked as ${c.success?"completed":"failed"}`),console.log("[v0] Updating profile final status..."),await s.from("gologin_profiles").update({status:c.success?"idle":"error",last_run:new Date().toISOString()}).eq("id",i.id),console.log(`[v0] ✓ Profile status updated to ${c.success?"idle":"error"}`),console.log("[v0] Creating activity log..."),await s.from("activity_logs").insert({profile_id:i.id,task_id:e.id,action:e.task_type,details:c.result||{},duration_ms:c.duration,success:c.success}),console.log("[v0] ✓ Activity logged"),console.log("[v0] ========================================"),console.log(`[v0] ${c.success?"✓✓✓":"❌"} Task ${e.id} ${c.success?"completed successfully":"failed"}`),!c.success&&c.error&&console.log(`[v0] Error: ${c.error}`),console.log("[v0] ========================================")}catch(t){console.error("[v0] ========================================"),console.error(`[v0] ❌ Error processing task ${e.id}`),console.error(`[v0] Error type: ${t.name}`),console.error(`[v0] Error message: ${t.message}`),console.error("[v0] Error stack:",t.stack),console.error("[v0] ========================================");let o=await (0,r.t)();await o.from("automation_tasks").update({status:"failed",completed_at:new Date().toISOString(),error_message:t.message}).eq("id",e.id),await o.from("gologin_profiles").update({status:"error"}).eq("id",e.profile_id)}}async scheduleRecurringTask(e,o,t,s){let a=await (0,r.t)(),{data:i}=await a.auth.getUser();if(!i.user)throw Error("Unauthorized");let{data:n,error:l}=await a.from("automation_tasks").insert({profile_id:e,task_type:o,config:s||{},scheduled_at:new Date().toISOString(),created_by:i.user.id}).select().single();if(l)throw l;return n}}s()}catch(e){s(e)}})}};var o=require("../../../../webpack-runtime.js");o.C(e);var t=e=>o(o.s=e),s=o.X(0,[948,227,59,338],()=>t(3052));module.exports=s})();